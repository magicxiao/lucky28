_        = require 'lodash'
mysql    = require 'mysql'
async    = require 'async'
Emitter  = require('events').EventEmitter
dbconfig = require('./configs').db

TIMEOUT  = 30000000 # https://www.npmjs.com/package/mysql#timeouts

class Pool extends Emitter

  ###*
   * @type {Object}
   * @privite
  ###
  poolCluster: null

  ###*
   * Constructor
   * @param  {Object} opts  the option params
   * @param  {Function} [opts.errListener]  error listener function
   * @param  {Function} [opts.infoListener] info listener function
   * @return {Void}
  ###
  constructor: (opts) ->
    eh = if opts and opts.errListener then opts.errListener else @errorHandler
    ih = if opts and opts.infoListener then opts.infoListener else @infoHandler
    @on 'error', eh
    @on 'info', ih
    @init()

  ###*
   * Default error listener
   * @param  {Mixed} err  err message
   * @return {Void}
  ###
  errorHandler: (err) ->
    console.log err

  ###*
   * Default info listener
   * @param  {Mixed} info  info message
   * @return {Void}
  ###
  infoHandler: (info) ->
    console.log info

  ###*
   * Initialize pool cluster
   * @return {Void}
  ###
  init: ->
    clusterConfig =
      removeNodeErrorCount: 10
      restoreNodeTimeout: 10000
      connectionLimit: 4
    @poolCluster = mysql.createPoolCluster(clusterConfig)

    for nodeId, conf of dbconfig
      conf.connectionLimit = 4
      conf.acquireTimeout = 200000
      @poolCluster.add nodeId, conf

    @poolCluster.on 'remove', (nodeId)->
      @emit 'info', "REMOVE NODE : #{nodeId}"
      # 将节点重新加入到cluster
      conf = dbconfig[nodeId]
      conf.connectionLimit = 10
      @poolCluster.add nodeId, conf

  ###*
   * Get the specified node pool instance
   * @param  {String} nodeId  node ID
   * @return {Object}         pool instance
  ###
  getPool: (nodeId) ->
    return cb new Error('nodeId is invalid.') unless nodeId
    @poolCluster.of(nodeId, 'RANDOM')

  ###*
   * Get the specified node connection
   *
   * @privite
   *
   * @param  {String}   nodeId  node ID
   * @param  {Function} cb      callback Function
   * @return {Mixed}            error or connection
  ###
  _getConn = (poolCluster, nodeId, cb) ->
    nodeId = _.toString nodeId
    return cb new Error('nodeId is invalid.') unless nodeId
    return cb new Error('poolCluster is invalid.') unless poolCluster

    poolCluster.getConnection nodeId, (err, conn) ->
      if err
        conn.release() if conn
        return cb err, null if cb
      cb err, conn if cb

  ###*
   * Get the specified node connection
   *
   * @public
   *
   * @param  {String}   nodeId  node ID
   * @param  {Function} cb      callback Function
   * @return {Mixed}            error or connection
  ###
  getConn: (nodeId, cb) ->
    _getConn(@poolCluster, nodeId, cb)

  ###*
   * Get the specified node and specified database connection
   *
   * @private
   *
   * @param  {Object}   node node config, ex: {nodeId: '1', dbName: 'test'}
   * @param  {Function} callback callback Function
   * @return {Mixed}         error or connection
  ###
  _getNodeConn = (poolCluster, node, callback) ->
    return callback new Error('node is invalid.') unless node
    return callback new Error('node must be an object.') unless _.isPlainObject node
    return callback new Error('poolCluster is invalid.') unless poolCluster

    async.waterfall([
      (cb) ->
        _getConn poolCluster, node.nodeId, cb
      (conn, cb) ->
        conn.changeUser {database: node.dbName}, (err) ->
          conn.release() if err
          cb err, conn
    ], (err, conn) ->
      callback err, conn
    )

  ###*
   * Get the specified node and specified database connection
   *
   * @public
   *
   * @param  {Object}   node  node config, ex: {nodeId: '1', dbName: 'test'}
   * @param  {Function} cb    callback Function
   * @return {Mixed}          error or connection
  ###
  getNodeConn: (node, cb) ->
    _getNodeConn(@poolCluster, node, cb)

  ###*
   * Release the connection
   * @param  {Object}   conn connection instance
   * @param  {Function} cb   callback Function
   * @return {Mixed}         error or true
  ###
  releaseConn: (conn, cb) ->
    return cb new Error('conn is invalid.') unless conn
    try
      conn.release()
    catch err
      return cb err if cb
    cb null, true

  ###*
   * Close the pool
   * @return {Mixed}     error or null
  ###
  destroy: ->
    @poolCluster.end() if @poolCluster

  ###*
   * Node query
   * @param  {String}   nodeId    node ID
   * @param  {String}   sql       SQL
   * @param  {Function} callback  callback Function
   * @return {Mixed}              error or rows
  ###
  query: (nodeId, sql, callback) ->
    nodeId = _.toString nodeId
    return callback new Error('nodeId is invalid.') unless nodeId
    return callback new Error('sql is invalid.') unless sql

    async.waterfall([
      (cb) =>
        _getConn @poolCluster, nodeId, cb
      (conn, cb) ->
        conn.query {sql: sql, timeout: TIMEOUT}, (err, rows) ->
          return cb err, null if err
          conn.release()
          cb null, rows
    ], (err, result) ->
      callback err, result
    )

  ###*
   * Node query
   * @param  {String}   nodeId    node ID
   * @param  {String}   dbName    database name
   * @param  {String}   sql       SQL
   * @param  {Function} callback  callback Function
   * @return {Mixed}              error or rows
  ###
  DBQuery: (nodeId, dbName, sql, callback) ->
    nodeId = _.toString nodeId
    return callback new Error('nodeId is invalid.') unless nodeId
    return callback new Error('dbName is invalid.') unless dbName
    return callback new Error('sql is invalid.') unless sql

    startTime   = new Date()
    costTime    = null
    async.waterfall([
      (cb) =>
        _getNodeConn @poolCluster, {nodeId, dbName}, cb
      (conn, cb) ->
        conn.query {sql: sql, timeout: TIMEOUT}, (err, rows) ->
          return cb err, null if err
          # 计算查询时间,返回给上层
          endTime = new Date()
          costTime = endTime.getTime() - startTime.getTime()
          conn.release()
          cb null, rows
    ], (err, result) ->
      callback err, result, dbName, costTime
    )

# Singleton pool
module.exports = new Pool()
